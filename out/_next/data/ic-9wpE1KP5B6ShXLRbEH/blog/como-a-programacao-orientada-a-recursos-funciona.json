{"pageProps":{"page":{"__metadata":{"id":"content/pages/blog/como-a-programacao-orientada-a-recursos-funciona.md","source":"sourcebit-source-filesystem","sourceName":"pages","sourcePath":"/Users/coflow/Desktop/digifi_ei/content/pages","relSourcePath":"blog/como-a-programacao-orientada-a-recursos-funciona.md","relProjectPath":"content/pages/blog/como-a-programacao-orientada-a-recursos-funciona.md","urlPath":"/blog/como-a-programacao-orientada-a-recursos-funciona","pageCssClasses":["page-blog","page-blog-como-a-programacao-orientada-a-recursos-funciona"]},"layout":"PostLayout","metaTitle":"Como a programação orientada a recursos funciona? ","addTitleSuffix":true,"metaTags":[],"title":"Como a programação orientada a recursos funciona? ","colors":"colors-d","date":"2022-12-06","excerpt":"O objetivo da Dapper Labs é usar a tecnologia descentralizada, especificamente non-fungible tokens (NFTs), para dar poder aos criadores e permitir que eles monetizem e promovam o próprio trabalho de maneira mais eficiente. A empresa acredita que as NFTs ainda têm um grande potencial para redefinir a criatividade, as comunidades de fãs e as experiências dos consumidores na blockchain. A Dapper Labs tem trabalhado em produtos como NBA Top Shot, CryptoKitties, NFL All Day, Dapper Wallet e outros para mostrar como as NFTs podem ser usadas para criar novas experiências, conectar fãs e criar conexões mais profundas no mundo digital. A empresa acredita que as NFTs são poderosas para permitir a participação e o envolvimento das comunidades, bem como para permitir que os fãs apoiem criadores e comunidades e expressem a própria individualidade.","featuredImage":{"type":"ImageBlock","url":"/images/capas/Como a programação orientada a recursos funciona diegofornalha.png","altText":"Como a programação orientada a recursos funciona?","caption":"O EVM (Ethereum Virtual Machine) ou WASM (WebAssembly) são opções ideais para ativos digitais, pois permitem que esses ativos sejam rotulados como \"recursos\" e sejam acompanhados por regras especiais que mantêm seu valor. Essas regras incluem a existência exclusiva de um recurso em um lugar específico, a impossibilidade de duplicação ou exclusão acidental e a propriedade determinada pelo local de armazenamento. Além disso, o acesso aos métodos de um recurso é limitado ao proprietário e as regras devem ser aplicadas enquanto o código é executado na blockchain para evitar invasões. Se essas regras forem seguidas corretamente, é possível armazenar ativos importantes de forma segura em estruturas de dados controladas por código de usuário. Um exemplo de como isso pode ser aplicado é o uso de tokens não fungíveis (NFTs) como CryptoKitties, que são indivisíveis, não copiáveis e podem ter um único proprietário direto. No modelo de recursos, o próprio CryptoKitty é armazenado diretamente na conta do proprietário, enquanto no modelo de ledger, é armazenado em um contrato inteligente centralizado.","width":800,"height":450},"media":{"type":"ImageBlock","url":"/images/capas/Como a programação orientada a recursos funciona diegofornalha.png","altText":"Como a programação orientada a recursos funciona? ","caption":"O EVM (Ethereum Virtual Machine) ou WASM (WebAssembly) são opções ideais para ativos digitais, pois permitem que esses ativos sejam rotulados como \"recursos\" e sejam acompanhados por regras especiais que mantêm seu valor. Essas regras incluem a existência exclusiva de um recurso em um lugar específico, a impossibilidade de duplicação ou exclusão acidental e a propriedade determinada pelo local de armazenamento. Além disso, o acesso aos métodos de um recurso é limitado ao proprietário e as regras devem ser aplicadas enquanto o código é executado na blockchain para evitar invasões. Se essas regras forem seguidas corretamente, é possível armazenar ativos importantes de forma segura em estruturas de dados controladas por código de usuário. Um exemplo de como isso pode ser aplicado é o uso de tokens não fungíveis (NFTs) como CryptoKitties, que são indivisíveis, não copiáveis e podem ter um único proprietário direto. No modelo de recursos, o próprio CryptoKitty é armazenado diretamente na conta do proprietário, enquanto no modelo de ledger, é armazenado em um contrato inteligente centralizado.","width":800,"height":450},"bottomSections":[],"metaDescription":null,"socialImage":null,"author":null,"markdown_content":"Entre as opções que EVM ou WASM e são um ajuste perfeito para ativos digitais.\n\nA rotulagem de algo como um “recurso” informa ao ambiente de programação que essa estrutura de dados representa algo de valor tangível e que todo código que interage com essa estrutura de dados precisa seguir uma série de regras especiais que manterão o valor dessa estrutura de dados.\n\nEntão, quais são essas regras?\n\n1.  **Cada recurso existe exatamente em um lugar a qualquer momento.**\n\nOs recursos não podem ser duplicados ou excluídos acidentalmente, por erro de programação ou código malicioso.\n\n2.  **A propriedade de um recurso é definida por onde ele é armazenado.**\n\nNão há razão central que precise ser consultada para determinar a propriedade.\n\n3.  **O acesso aos métodos em um recurso é limitado ao proprietário.**\n\nPor exemplo, apenas o proprietário de um CryptoKitty pode iniciar uma operação de criação que levará ao nascimento de um novo Kitty.\n\nNão basta que o status especial dos objetos Resource seja aplicado apenas pelo compilador.\n\nAs regras devem ser aplicadas enquanto o código estiver realmente sendo executado na blockchain, seria muito fácil para um invasor usar uma cópia comprometida do compilador que ignora as regras que mantêm os recursos seguros.\n\nContudo! Se você aplicar essas regras corretamente, poderá permitir que o ativo mais importante da rede do token nativo seja armazenado com segurança dentro de estruturas de dados controladas por código enviado pelo usuário.\n\n# **Mostre-me um exemplo!**\n\nA maneira mais fácil de pensar sobre Recursos é pensar em um exemplo usando um Token Não Fungível (NFT), como um CryptoKitty.\n\nCada CryptoKitty é indivisível, não copiável e pode ter um único proprietário direto, que corresponde diretamente à construção de programação de Recursos.\n\nEm um modelo de Ledger como o Ethereum, todos os CryptoKitties são armazenados em um único contrato inteligente como uma lista gigante. A propriedade de cada Kitty é rastreada armazenando o ID da conta de cada proprietário em um livro central, e a única maneira de alterar a propriedade de uma Kitty é entrar em contato com o livro central e solicitar que ele atualize o ID da conta associado a essa Kitty.\n\n`contract KittyLedger {     struct Kitty {}     priv let kitties: {Int: Kitty}     fun transfer(kittyId: Int, newOwner: AccountId) {         if (msg.sender == kitties[kittyId].owner) {             kitties[kittyId].owner = newOwner         }     } } transaction(signer: Account) {     // diz ao razão central para atribuir a propriedade de     // myKittyId para uma conta diferente centralKittyLedger.transfer(myKittyId, receiverAccountId) }`\n\nNo Modelo de Recursos, o próprio Kitty é representado como um objeto de Recursos e é armazenado \\*diretamente na conta que a possui.\n\n\\*Assim como no mundo físico, a propriedade é representada pela posse. Você não precisa procurar em um livro central para ver se possui algo, ou o armazena em sua conta ou não.\n\nE se você tiver, pode transferi-lo ou controlá-lo de outra forma, e se você *não* tem, não há como capturá-lo ou alterá-lo.\n\n`contract CryptoKitties {     //As contas armazenam uma coleção em seu recurso de armazenamento de conta KittyCollection {         // Cada coleção tem funções para //mover recursos armazenados para dentro e para fora         fun withdraw(kittyId: int): CryptoKitty         fun deposit(kitty: CryptoKitty)     }     //Os objetos de recurso que podem ser armazenados no recurso de coleção CryptoKitty {} } transaction(signer: Account) {     //Remove o Kitty da coleção do signatário e o armazena     // temporariamente na pilha.      let theKitty <- signer.kittyCollection.withdraw(kittyId: myKittyId)     // Move o Kitty para a conta do destinatário     let receiver = getAccount(receiverAccountId)     receiver.kittyCollection.deposit(kitty: <-theKitty) }`\n\n*Nota: para manter o foco nas diferenças entre os modelos de contabilidade e propriedade direta, os dois exemplos acima ignoram questões como controle de acesso, definindo todas as variáveis, e outros fatores com os quais o código ativo precisaria se preocupar.*\n\n# **Por que os recursos importam**\n\nAlém da vitória óbvia de incluir abstrações para gerenciar a propriedade, existem vários outros benefícios secundários decorrentes do uso de Recursos, cada um dos quais bastante significativo por si só:\n\n# **Aluguel de Estado**\n\nAs plataformas escaláveis de contratos inteligentes precisam de alguma maneira de cobrar “ aluguel de estado ” para que os dados armazenados no blockchain sejam pagos ou removidos do conjunto de trabalho.\n\nCom o modelo de contabilidade, é difícil saber quem deve pagar esse aluguel. Por exemplo, o contrato CryptoKitties representa dezenas de milhares de jogadores com quase dois milhões de Kitties e mais de 111MB de dados na blockchain.\n\nA Ethereum não fornece nenhuma maneira de cobrar aluguel de maneira justa a todos os proprietários da Kitty.\n\nUsando um modelo de propriedade direta via Tipos de Recursos, cada Kitty seria armazenada dentro da conta de seu proprietário, juntamente com os outros ativos dessa pessoa.\n\nA responsabilidade de quem precisa pagar por esse armazenamento é clara.\n\nAlém disso, usuários individuais (assistidos pelo software cliente) podem arquivar ativos não utilizados para reduzir seus custos e reduzir a carga na rede.\n\n# **Propriedade flexível**\n\nO uso de um modelo de contabilidade para propriedade limita os tipos de relacionamentos com proprietários disponíveis.\n\nPor exemplo, o ERC-721 define um modelo de propriedade para NFTs que pressupõe que apenas endereços Ethereum podem possuir uma NFT.\n\nNo entanto, a ideia de um ativo em si possuir outros ativos (como um CryptoKitty que possui um par bacana de óculos de sol ) é muito interessante em alguns casos de uso, e exigiu a criação de uma nova especificação (ERC-998).\n\nO ERC-998 é muito poderoso, mas também é muito mais complicado que o ERC-721. Implementá-lo adequadamente é muito difícil e aplicar retroativamente seus recursos aos ativos existentes do ERC-721 é efetivamente impossível.\n\nO modelo de propriedade direta permite que qualquer ativo modelado usando Tipos de Recursos seja armazenado com segurança em qualquer lugar do sistema, incluindo “dentro” de outros ativos, quando apropriado.\n\nTodas as garantias de segurança e valor podem ser mantidas pelo sistema de tempo de execução, enquanto desbloqueia a flexibilidade criativa para desenvolvedores sem complexidade indevida.\n\n# **Segurança baseada em capacidade**\n\nOs tipos de recursos fornecem todas as garantias necessárias para implementar o conceito de “Capacidades” do [Segurança baseada em capacidade](https://en.wikipedia.org/wiki/Capability-based_security) modelo. Os recursos são um mecanismo poderoso para definir sistemas seguros e podem facilitar a adesão ao [Princípio do Menos Privilégio](https://en.wikipedia.org/wiki/Principle_of_least_privilege) (uma prática recomendada comum em sistemas de segurança).\n\nOs modelos de segurança baseados em capacidade são geralmente considerados muito mais fáceis de raciocinar sobre, (o que aumenta a segurança), permitindo maior flexibilidade.\n\n# **Eliminando erros de reentrada**\n\n[O bug de contrato inteligente mais famoso da história da Ethereum](https://www.wired.com/2016/06/50-million-hack-just-showed-dao-human/) foi devido a um problema de reentrada, e os desenvolvedores de solidity precisa estar constantemente vigilantes contra a introdução de fluxo lógico suscetível a ataques de reentrada.\n\nFelizmente, os métodos definidos nos recursos dos objetos não podem ser vítimas de nenhuma exploração de reentrada.\n\nParece uma afirmação ousada! No entanto, segue naturalmente como os Recursos são definidos: cada Recurso tem um único proprietário e somente o proprietário de um Recurso pode chamar os métodos nele.\n\nSe um método de recurso estiver “na pilha”, sabemos que a referência de propriedade única a esse objeto já está em uso simplesmente não é possível que qualquer código que chamamos de dentro desse método, no entanto indiretamente, obtenha uma segunda referência a esse objeto para fazer uma chamada de método reentrante.\n\nObviamente, trabalhar diretamente com o estado compartilhado global (ignorando o uso de objetos de Recursos) ainda pode criar um código vulnerável a erros de reentrada.\n\nÉ por isso que o estilo idiomático de cadência é usar Recursos para todo o estado compartilhado autores de contratos inteligentes que adotam Recursos nunca precisam pensar em bugs de reentrada novamente!\n\n# **Mais sobre recursos**\n\nPara aprofundar os recursos e a programação orientada a recursos, você pode:\n\n*   Leia o [Mover papel técnico](https://developers.libra.org/docs/assets/papers/libra-move-a-language-with-programmable-resources/2019-09-26.pdf)[documentos do desenvolvedor](https://developers.libra.org/docs/move-overview) e\n\n*   Leia o [Documentos do desenvolvedor de Flow](https://docs.onflow.org/docs)[Introdução à Cadence](https://docs.onflow.org/docs/introduction)\n\n*   Aprenda a linguagem de programação Cadence em [Flow Playground](https://www.onflow.org/play)\n"},"site":{"__metadata":{"id":"content/data/config.json","source":"sourcebit-source-filesystem","sourceName":"data","sourcePath":"/Users/coflow/Desktop/digifi_ei/content/data","relSourcePath":"config.json","relProjectPath":"content/data/config.json"},"type":"Config","header":{"headerVariant":"variant-b","isSticky":true,"primaryColors":"colors-b","secondaryColors":"colors-d","isTitleVisible":false,"primaryLinks":[{"type":"Link","label":"Home","altText":"Inicio","url":"/","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"DropdownLink","label":"About","dropdownLinks":[{"type":"Link","label":"Curso Cadence","url":"/curso","altText":"Curso Cadence"},{"type":"Link","label":"Blog","altText":"Blog","url":"/blog","showIcon":true,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"Learn More","altText":"","url":"/curso","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""}]},{"type":"DropdownLink","label":"Volunteers","dropdownLinks":[{"type":"Link","label":"2023","altText":"Link to 2023 team's page","url":"/registro/2023","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"Advocates","altText":"Advocates","url":"https://flow.coflow.com.br/flow-brasil-embaixador-aprendiz/","showIcon":true,"icon":"arrowRight","iconPosition":"right","elementId":""}]},{"type":"DropdownLink","label":"Partnerships","altText":"Parcerias","dropdownLinks":[{"type":"Link","label":"GeekHunter","altText":"Recurtamento e Seleção","url":"/2023/janeiro/parcerias/geekhunter/","showIcon":true,"icon":"arrowRight","iconPosition":"left","elementId":""},{"type":"Link","label":"News","altText":"Novidades","url":"/2023/janeiro/news","showIcon":true,"icon":"arrowRight","iconPosition":"right","elementId":""}]},{"type":"Link","label":"Blog ","altText":"Blog","url":"/blog","showIcon":true,"icon":"arrowRightCircle","iconPosition":"left","elementId":""}],"secondaryLinks":[{"type":"Button","label":"Join Discord","altText":"Entrar no Discord","style":"secondary","url":"https://discord.com/invite/hT8EpC5mUN","showIcon":true,"icon":"cart","iconPosition":"right","elementId":""}],"styles":{"self":{"width":"wide","padding":["pl-5","pt-5","pb-5","pr-5"]}},"logo":{"type":"ImageBlock","url":"/images/padrao/flow-coflow-logo.png","altText":"CoFlow Logo","caption":"CoFlow","width":114,"height":48,"elementId":""},"title":"CoFlow"},"footer":{"variant":"variant-b","colors":"colors-b","contacts":{"addressAltText":"Our address"},"copyrightText":"CoFlow","primaryLinks":[{"type":"Link","label":"Home","url":"/","altText":"Home"},{"type":"Link","label":"Contact Us","altText":"Contact Us","url":"https://wa.me/5521997806363?text=Ol%C3%A1","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"CURSO CADENCE","altText":"CURSO CADENCE","url":"/curso","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"TERMO DE USO","altText":"TERMO DE USO","url":"/termo-de-uso","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"POLÍTICA DE PRIVACIDADE","altText":"POLÍTICA DE PRIVACIDADE","url":"/politica-de-privacidade","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""}],"socialLinks":[{"type":"Social","label":"Email","altText":"","url":"mailto:diegofornalha@gmail.com","icon":"mail","style":"link","elementId":""},{"type":"Social","altText":"Instagram","label":"Instagram","url":"http://www.instagram.com/diegofornalha","icon":"instagram"},{"type":"Social","altText":"Linkedin","label":"Linkedin","url":"https://www.github.com/diegofornalha","icon":"github"},{"type":"Social","label":"Youtube","altText":"Youtube","icon":"youtube","style":"link","elementId":"","url":"https://www.youtube.com/diegofornalha"},{"type":"Social","altText":"Twitter","label":"Twitter","url":"https://twitter.com/diegofornalha","icon":"twitter"},{"type":"Social","label":"Linkedin","altText":"Linkedin","url":"https://linkedin.com/in/diegofornalha","icon":"linkedin","style":"link","elementId":""}],"styles":{"self":{"width":"narrow"}},"logo":{"type":"ImageBlock","url":"/images/padrao/flow-coflow-logo.png","altText":"CoFlow Logo","caption":"CoFlow Logo","width":114,"height":48,"elementId":""}},"defaultMetaTags":[{"type":"MetaTag","property":"og:title","content":"CoFlow"}],"titleSuffix":"Coflow","env":{}}},"__N_SSG":true}