{"pageProps":{"page":{"__metadata":{"id":"content/pages/blog/a-anatomia-de-um-flow-dapp.md","source":"sourcebit-source-filesystem","sourceName":"pages","sourcePath":"/Users/coflow/Desktop/digifi_ei/content/pages","relSourcePath":"blog/a-anatomia-de-um-flow-dapp.md","relProjectPath":"content/pages/blog/a-anatomia-de-um-flow-dapp.md","urlPath":"/blog/a-anatomia-de-um-flow-dapp","pageCssClasses":["page-blog","page-blog-a-anatomia-de-um-flow-dapp"]},"layout":"PostLayout","metaTitle":"A anatomia de um Flow Dapp","addTitleSuffix":true,"metaTags":[],"title":"A anatomia de um Flow Dapp","colors":"colors-d","featuredImage":{"type":"ImageBlock","url":"/images/capas/a anatomia da uma dapp diego fornalha.png","altText":"A anatomia de um Flow Dapp","caption":"","width":800,"height":450},"media":{"type":"ImageBlock","url":"/images/capas/a anatomia da uma dapp diego fornalha.png","altText":"A anatomia de um Flow Dapp","width":800,"height":450,"caption":"A anatomia de um Flow Dapp"},"bottomSections":[{"type":"FeaturedPostsSection","colors":"colors-b","elementId":"","showDate":false,"showAuthor":false,"showExcerpt":false,"showReadMoreLink":false,"readMoreLinkLabel":"Saiba Mais","variant":"variant-b","actions":[],"styles":{"self":{"height":"auto","width":"wide","padding":["pt-24","pb-24","pl-4","pr-4"],"justifyContent":"center"},"title":{"textAlign":"center"},"subtitle":{"textAlign":"center"},"actions":{"justifyContent":"center"}},"subtitle":"","posts":[{"__metadata":{"id":"content/pages/blog/escreva-contratos-inteligente-em-cadence-para-votacoes.md","source":"sourcebit-source-filesystem","sourceName":"pages","sourcePath":"/Users/coflow/Desktop/digifi_ei/content/pages","relSourcePath":"blog/escreva-contratos-inteligente-em-cadence-para-votacoes.md","relProjectPath":"content/pages/blog/escreva-contratos-inteligente-em-cadence-para-votacoes.md"},"layout":"PostLayout","metaTitle":"Escreva Contratos Inteligente em Cadence Para Votações","addTitleSuffix":true,"metaTags":[],"title":"Escreva Contratos Inteligente em Cadence Para Votações","colors":"colors-d","date":"2022-12-12","excerpt":"O smart contract em Cadence é um código que é executado em uma rede blockchain, que é uma tecnologia de banco de dados descentralizada. Ele é utilizado para realizar eleições de forma segura e eficiente, permitindo que os participantes votem em uma das propostas disponíveis e armazenando as contagens de votos para cada uma das propostas. O smart contract possui três recursos principais: MaioriaGanha, Voto e Administrar. O recurso MaioriaGanha é o contrato principal e define as variáveis propostas e votos, bem como as funções processar e init. O recurso Voto permite que os participantes votem em uma das propostas e armazenem suas escolhas em uma variável escolha. O recurso Administrar permite que o administrador inicialize as propostas e crie novas instâncias do recurso Voto.","featuredImage":{"type":"ImageBlock","url":"/images/capas/Escreva Contratos Inteligente em Cadence Para Votações diegofornalha.png","altText":"Escreva Contratos Inteligente em Cadence Para Votações","caption":"O smart contract em Cadence é um código que é executado em uma rede blockchain, que é uma tecnologia de banco de dados descentralizada. Ele é utilizado para realizar eleições de forma segura e eficiente, permitindo que os participantes votem em uma das propostas disponíveis e armazenando as contagens de votos para cada uma das propostas. O smart contract possui três recursos principais: MaioriaGanha, Voto e Administrar. O recurso MaioriaGanha é o contrato principal e define as variáveis propostas e votos, bem como as funções processar e init. O recurso Voto permite que os participantes votem em uma das propostas e armazenem suas escolhas em uma variável escolha. O recurso Administrar permite que o administrador inicialize as propostas e crie novas instâncias do recurso Voto.","width":800,"height":450},"media":{"type":"ImageBlock","url":"/images/capas/Escreva Contratos Inteligente em Cadence Para Votações diegofornalha.png","altText":"Escreva Contratos Inteligente em Cadence Para Votações","caption":"O smart contract em Cadence é um código que é executado em uma rede blockchain, que é uma tecnologia de banco de dados descentralizada. Ele é utilizado para realizar eleições de forma segura e eficiente, permitindo que os participantes votem em uma das propostas disponíveis e armazenando as contagens de votos para cada uma das propostas. O smart contract possui três recursos principais: MaioriaGanha, Voto e Administrar. O recurso MaioriaGanha é o contrato principal e define as variáveis propostas e votos, bem como as funções processar e init. O recurso Voto permite que os participantes votem em uma das propostas e armazenem suas escolhas em uma variável escolha. O recurso Administrar permite que o administrador inicialize as propostas e crie novas instâncias do recurso Voto.","width":800,"height":450},"bottomSections":[],"metaDescription":"O smart contract em Cadence é um código que é executado em uma rede blockchain, que é uma tecnologia de banco de dados descentralizada. Ele é utilizado para realizar eleições de forma segura e eficiente, permitindo que os participantes votem em uma das propostas disponíveis e armazenando as contagens de votos para cada uma das propostas. O smart contract possui três recursos principais: MaioriaGanha, Voto e Administrar. O recurso MaioriaGanha é o contrato principal e define as variáveis propostas e votos, bem como as funções processar e init. O recurso Voto permite que os participantes votem em uma das propostas e armazenem suas escolhas em uma variável escolha. O recurso Administrar permite que o administrador inicialize as propostas e crie novas instâncias do recurso Voto.","socialImage":"/images/capas/Escreva Contratos Inteligente em Cadence Para Votações diegofornalha.png","author":null,"markdown_content":"Hoje nós vamos ver como é fácil programar seu primeiro smart contract em Cadence de votação, ele sem dúvidas é o verdadeiro mestre das eleições!\n\nEle permite que os participantes votem em uma das propostas disponíveis e armazena as contagens de votos para cada uma das propostas.\n\nEle possui três recursos principais:\n\nMaioriaGanha,\n\nVoto e\n\nAdministrar.\n\nCom esses recursos, o smart contract em Cadence é capaz de realizar eleições de forma eficiente e segura.\n\nO recurso MaioriaGanha é o contrato principal e define as variáveis propostas e votos, bem como as funções processar e init.\n\nA variável propostas é uma lista de strings que armazena as propostas disponíveis para votação, enquanto a variável votos é um dicionário que armazena a contagem de votos para cada uma das propostas.\n\nA função processar é usada para processar um voto quando um participante decide finalizá-lo, enquanto a função init é chamada quando o contrato é criado e inicializa as variáveis propostas e votos com valores vazios e salva uma instância do recurso Administrar na storage do contrato.\n\nO recurso Voto é usado para permitir que os participantes votem em uma das propostas e armazenar suas escolhas em uma variável escolha.\n\nQuando uma nova instância do recurso Voto é criada, a função init é chamada para inicializar a variável escolha com um dicionário vazio e preencher o dicionário com as propostas disponíveis. O participante pode chamar a função vote para votar em uma das propostas, passando o índice da proposta como argumento.\n\nO recurso Administrar permite que o administrador inicialize as propostas e crie novas instâncias do recurso Voto. A função inicializePropostas é usada para atribuir a lista de propostas fornecida à variável propostas do contrato principal e inicializar a variável votos com um dicionário vazio, com chaves correspondentes a cada uma das propostas.\n\nA função emitirVoto é usada para criar uma nova instância do recurso Voto e retorná-la.\n\nEspero que isso tenha ajudado a esclarecer o que o seu smart contract está fazendo de forma mais detalhada e descontraída. Se você tiver mais perguntas ou precisar de mais assistência, não hesite em perguntar.\npub contract MaioriaGanha {\n    pub var propostas: [String]\n    pub let votos: {Int: Int}\n\n    pub resource Voto {\n        pub let propostas: [String]\n        pub var escolha: {Int: Bool}\n\n        init() {\n            self.propostas = MaioriaGanha.propostas\n            self.escolha = {}\n            var i = 0\n            while i < self.propostas.length {\n                self.escolha[i] = false\n                i = i + 1\n            }\n        }\n        pub fun vote(propostas: Int) {\n            pre {\n                propostas >= 0\n                propostas < self.propostas.length\n            }\n            self.escolha[propostas] = true\n        }\n    }\n\n    pub resource Administrar {\n        pub fun inicializePropostas(_ propostas: [String]) {\n            pre {\n                MaioriaGanha.propostas.length == 0\n                propostas.length > 0\n            }\n            MaioriaGanha.propostas = propostas\n\n            var i = 0\n            while i < propostas.length {\n                MaioriaGanha.votos[i] = 0\n                i = i + 1\n            }\n        }\n\n        pub fun emitirVoto(): @Voto {\n            return <-create Voto()\n        }\n    }\n\n    pub fun processar(voto: @Voto) {\n        var index = 0\n        while index < self.propostas.length {\n            if voto.escolha[index]! {\n                self.votos[index] = self.votos[index]! + 1\n            }\n            index = index + 1;\n        }\n        destroy voto\n    }\n    init() {\n        self.propostas = []\n        self.votos = {}\n\n        self.account.save<@Administrar>(<-create Administrar(), to: /storage/CalcularVotos)\n    }\n}\nParece que o seu código em Cadence é uma transação que permite ao administrador inicializar uma lista de propostas para eventos. Quando a transação é executada, ela solicita ao administrador que forneça suas credenciais de autenticação e, em seguida, usa essas credenciais para obter uma referência para o recurso Administrar do contrato MaioriaGanha.\n\nEm seguida, a função inicializePropostas é chamada no recurso Administrar, passando uma lista de três cidades como argumento: Rio de Janeiro, São Paulo e Floripa.\n\nEssa função atribui a lista de propostas fornecida à variável propostas do contrato principal e inicializa a variável votos com um dicionário vazio, com chaves correspondentes a cada uma das propostas.\n\nPor fim, a transação exibe uma mensagem de log informando que as sugestões de locais para eventos foram publicadas.\nimport MaioriaGanha from 0x01\n\ntransaction {\n    prepare(admin: AuthAccount) {\n\n        let adminRef = admin.borrow<&MaioriaGanha.Administrar>(from: /storage/CalcularVotos)!\n\n        adminRef.inicializePropostas(\n            [\"Rio de Janeiro\", \"Sao Paulo\",\"Floripa\" ]\n        )\n\n        log(\"Sugestoes de Locais para Eventos Publicada!\")\n    }\n}\nAgora veremos um contrato de uma transação que permite a um eleitor emitir um voto em uma das propostas disponíveis em um contrato MaioriaGanha\n. Quando a transação é executada, ela solicita ao administrador e ao eleitor que forneçam suas credenciais de autenticação.\n\nEm seguida, a transação obtém uma referência para o recurso Administrar do contrato MaioriaGanha e chama a função emitirVoto nesse recurso. A função emitirVoto cria uma nova instância do recurso Voto e retorna uma referência para ela.\n\nEm seguida, a transação salva a instância do recurso Voto na storage do eleitor e exibe uma mensagem de log informando que o acesso foi concedido.\nimport MaioriaGanha from 0x01\n\ntransaction {\n    prepare(admin: AuthAccount, eleitor: AuthAccount) {\n\n        let adminRef = admin.borrow<&MaioriaGanha.Administrar>(from: /storage/CalcularVotos)!\n\n        let voto <- adminRef.emitirVoto()\n\n        eleitor.save<@MaioriaGanha.Voto>(<-voto, to: /storage/Voto)\n\n        log(\"Acesso Concedido\")\n    }\n}\nAgora uma transação que permite a um eleitor emitir um voto em uma das propostas disponíveis em um contrato MaioriaGanha. Quando a transação é executada, ela solicita ao eleitor que forneça suas credenciais de autenticação e, em seguida, tenta carregar uma instância do recurso Voto da storage do eleitor.\n\nSe uma instância do recurso Voto for encontrada na storage do eleitor, a transação chama a função vote nessa instância, passando o valor 0 como argumento. Isso marca a primeira proposta da lista como a escolha do eleitor.\n\nEm seguida, a transação chama a função processar do contrato MaioriaGanha, passando a instância do recurso Voto como argumento. Isso adiciona o voto do eleitor à contagem de votos para a primeira proposta.\n\nPor fim, a transação exibe uma mensagem de log informando que o voto foi computado.\nimport MaioriaGanha from 0x01\n\ntransaction {\n    prepare(eleitor: AuthAccount) {\n\n        let voto <- eleitor.load<@MaioriaGanha.Voto>(from: /storage/Voto)!\n\n        voto.vote(propostas: 0)\n\n        MaioriaGanha.processar(voto: <-voto)\n\n        log(\"Voto computado\")\n    }\n}\nPor fim, no script template.\n\nQuando a função é chamada, ela exibe os valores da primeira, segunda e terceira propostas na lista de propostas, seguidos dos respectivos valores de votos.\n\nA função usa os índices 0, 1 e 2 para acessar os elementos da lista de propostas e do dicionário de votos, respectivamente. Isso significa que ela exibirá a primeira proposta da lista, seguida do número de votos para essa proposta, depois a segunda proposta da lista e o número de votos para ela, e assim por diante.\nimport MaioriaGanha from 0x01\n\npub fun main() {\n    log(MaioriaGanha.propostas[0])\n    log(MaioriaGanha.votos[0])\n\n    log(MaioriaGanha.propostas[1])\n    log(MaioriaGanha.votos[1])\n\n    log(MaioriaGanha.propostas[2])\n    log(MaioriaGanha.votos[2])\n}\nTry out this Playground project"},{"__metadata":{"id":"content/pages/blog/como-construir-um-dapp-para-cunhagem-de-nft-na-flow.md","source":"sourcebit-source-filesystem","sourceName":"pages","sourcePath":"/Users/coflow/Desktop/digifi_ei/content/pages","relSourcePath":"blog/como-construir-um-dapp-para-cunhagem-de-nft-na-flow.md","relProjectPath":"content/pages/blog/como-construir-um-dapp-para-cunhagem-de-nft-na-flow.md"},"layout":"PostLayout","metaTitle":"Como construir um Dapp para cunhagem de NFT na Flow","addTitleSuffix":true,"metaTags":[],"colors":"colors-d","date":"2022-12-08","excerpt":"Para configurar uma conta no blockchain Flow, é necessário gerar um par de chaves públicas e privadas. Isso pode ser feito usando o comando \"generateKeys\" da biblioteca \"flow-js\" ou através de outra ferramenta de geração de chaves. As chaves públicas e privadas são usadas para assinar transações no blockchain Flow e garantir a segurança da conta. Depois de gerar as chaves, é preciso criar uma conta no blockchain Flow usando as chaves e seguir as instruções fornecidas pela plataforma para configurar a conta. Depois de configurar a conta, você poderá implantar seu contrato inteligente no blockchain Flow.","featuredImage":{"type":"ImageBlock","url":"/images/capas/Como construir um Dapp para cunhagem de NFT na Flow diegofornalha.png","altText":"Como construir um Dapp para cunhagem de NFT na Flow","caption":"Para configurar uma conta no blockchain Flow, é necessário gerar um par de chaves públicas e privadas. Isso pode ser feito usando o comando \"generateKeys\" da biblioteca \"flow-js\" ou através de outra ferramenta de geração de chaves. As chaves públicas e privadas são usadas para assinar transações no blockchain Flow e garantir a segurança da conta. Depois de gerar as chaves, é preciso criar uma conta no blockchain Flow usando as chaves e seguir as instruções fornecidas pela plataforma para configurar a conta. Depois de configurar a conta, você poderá implantar seu contrato inteligente no blockchain Flow.","width":800,"height":450},"media":{"type":"ImageBlock","url":"/images/capas/Como construir um Dapp para cunhagem de NFT na Flow diegofornalha.png","altText":"Como construir um Dapp para cunhagem de NFT na Flow","caption":"Para configurar uma conta no blockchain Flow, é necessário gerar um par de chaves públicas e privadas. Isso pode ser feito usando o comando \"generateKeys\" da biblioteca \"flow-js\" ou através de outra ferramenta de geração de chaves. As chaves públicas e privadas são usadas para assinar transações no blockchain Flow e garantir a segurança da conta. Depois de gerar as chaves, é preciso criar uma conta no blockchain Flow usando as chaves e seguir as instruções fornecidas pela plataforma para configurar a conta. Depois de configurar a conta, você poderá implantar seu contrato inteligente no blockchain Flow.","width":800,"height":450},"bottomSections":[],"metaDescription":"Para configurar uma conta no blockchain Flow, é necessário gerar um par de chaves públicas e privadas. Isso pode ser feito usando o comando \"generateKeys\" da biblioteca \"flow-js\" ou através de outra ferramenta de geração de chaves. As chaves públicas e privadas são usadas para assinar transações no blockchain Flow e garantir a segurança da conta. Depois de gerar as chaves, é preciso criar uma conta no blockchain Flow usando as chaves e seguir as instruções fornecidas pela plataforma para configurar a conta. Depois de configurar a conta, você poderá implantar seu contrato inteligente no blockchain Flow.","socialImage":"/images/capas/Como construir um Dapp para cunhagem de NFT na Flow diegofornalha.png","title":"Como construir um Dapp para cunhagem de NFT na Flow","author":null,"markdown_content":"## Vamos colocar todo o conhecimento dos meus artigos anteriores em prática escrevendo e implantando um contrato inteligente, construindo um front-end e cunhando algumas NFTs\n\nSe você acompanhou a série Flow até agora, já sabe que o [O Flow Blockchain se destaca no manuseio de ativos digitais](https://medium.com/better-programming/an-introduction-to-the-flow-blockchain-60ccc7a35598), como NFTs. Foi construído desde o início como uma alternativa melhor ao congestionamento da rede da Ethereum e aos problemas de alta taxa.\n\nAlém disso, a linguagem de contrato inteligente Cadence é uma [programação orientada a recursos de primeira qualidade](https://medium.com/better-programming/smart-contracts-which-is-better-ethereum-or-flow-39f766c72e5d) linguagem que torna a criação e o gerenciamento de ativos digitais fáceis e eficientes. Embora a Solidez seja excelente em facilitar o Web3 por meio de contratos inteligentes, há desvantagens. A cadência aprimora as falhas da Solidity, fornecendo a capacidade de atualizar contratos e recursos inteligentes que reduzem o risco de erro humano, entre outras melhorias.\n\nE, finalmente, a lista de ferramentas e bibliotecas disponíveis para desenvolvedores que desejam começar é extensa. Então, vamos juntar tudo e construir algo sobre o Flow.\n\nEste artigo é um tutorial sobre a criação de um dapp completo de NFT para o Flow Blockchain.\n\n# **Vamos ao que interessa**\n\nPara o restante deste artigo, passaremos pelo processo de criação de um dapp de cunhagem NFT no blockchain Flow.\n\nComeçaremos com a configuração e implantação de um contrato inteligente da Cadence. Em seguida, criaremos um front-end para conectar-se ao nosso contrato inteligente e cunhar uma NFT na conta do usuário.\n\nA funcionalidade que construímos permitirá que os usuários conectem sua conta Flow, criem uma conta se ainda não tiverem uma e depois selecionem uma das três imagens para cunhar em uma NFT. Em seguida, o dapp exibirá as NFTs da nossa coleção que estão na conta do usuário. Será um excelente projeto para destacar a facilidade e eficiência da criação de NFTs no Flow e a eficácia da Biblioteca do Cliente Flow ( FCL ) para interagir com a blockchain.\n\nPara acompanhar este tutorial, você precisará das seguintes coisas:\n\n- [NodeJs](https://nodejs.org/en/download/)[NPM](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)\n    \n    e\n    \n- [A interface da linha de comando de fluxo](https://developers.flow.com/tools/flow-cli/install)\n    \n    ( CLI de fluxo )\n    \n- [Seu IDE favorito](https://code.visualstudio.com/)\n\nCom tudo isso instalado, vamos começar!\n\n# **1. Configurar conta de fluxo**\n\nAntes de começarmos a construir, precisaremos configurar uma conta no blockchain Flow para que possamos implantar nosso contrato inteligente. Execute o seguinte comando para gerar um novo par de chaves público e privado:\n\n```\nfluxo gerando chaves\n```\n\nCertifique-se de anotar os valores que o console gera, pois precisaremos deles nas etapas a seguir.\n\nEm seguida, vamos para o [Torneira de fluxo](https://testnet-faucet.onflow.org/) criar um novo endereço com base em nossas chaves e financiar nossa conta com alguns tokens de teste. Conclua as seguintes etapas para criar sua conta:\n\n1. Cole sua chave pública no campo de entrada especificado\n2. Mantenha os algoritmos de assinatura e hash definidos como padrão\n3. Complete o captcha\n4. Clique em Criar conta\n\n![https://miro.medium.com/max/520/1*C7g_k17hgGjzBACrFTzjBw.png](https://miro.medium.com/max/520/1*C7g_k17hgGjzBACrFTzjBw.png)\n\nCom uma geração de contas bem-sucedida, mantemos um diálogo com nosso novo endereço Flow, contendo 1.000 tokens FLOW.\n\n![https://miro.medium.com/max/700/1*rhyoqzmKbCgfDA-QEcEx3w.png](https://miro.medium.com/max/700/1*rhyoqzmKbCgfDA-QEcEx3w.png)\n\nCopie o endereço para uso na próxima etapa.\n\n# **2). Configurar o contrato inteligente**\n\nAntes de criarmos o front-end do projeto, vamos criar o contrato inteligente com o qual interagiremos mais tarde.\n\nNo terminal de comando, navegue até a pasta da qual você gostaria de trabalhar e digite o seguinte comando para iniciar um projeto:\n\n```\nfluxoinit\n```\n\nEste comando cria um `flow.json` arquivo dentro da pasta, onde colocaremos todas as informações necessárias para implantar nosso contrato inteligente.\n\nAbra o `flow.json` arquive no seu editor de códigos e configuraremos uma conta da rede de testes. Dentro do `accounts` seção, adicionaremos uma nova entrada chamada `testnet-account`, que contém nosso novo endereço e a chave privada gerada no `flow keys generate` comando mais cedo.\n\n```\n{\n \"emuladores\": {\n  \"padrão\": {\n   \"porta\":3569,\n\"Conta de serviço\":\"conta de emulador\"\n  }\n },\n \"contratos\": { },\n \"redes\": {\n  \"emulador\":\"127.0.0.1: 3569\",\n\"mainnet\":\"access.mainnet.nodes.onflow.org: 9000\",\n\"testnet\":\"access.devnet.nodes.onflow.org: 9000\"\n },\n \"contas\": {\n  \"conta de emulador\": {\n   \"endereço\":\"f8d6e0586b0a20c7\",\n\"chave\":\"2becfbede2fb89796ab68df3ec2a23c3627235ec250a3e5da41df850a8dd4349\"\n  },\n  \"conta de rede de teste\": {\n   \"endereço\":\"0x8e0dac5df6e8489e\",\n\"chave\":\"c91f4716a51a66683ccb090ca3e213b90e9f9ae2b1edd12defffe06c57edc\"\n  }\n },\n \"implantações\": { }\n}\n```\n\nEm seguida, criaremos um novo arquivo para escrever nosso contrato inteligente.\n\nAo escrever o código, você pode notar algumas diferenças na maneira como o Cadence lida com a criação de NFT em comparação com o Solidity. Por exemplo, as NFTs em Cadence são criadas como um recurso e cunhadas diretamente na conta do usuário. Por outro lado, as NFTs de solidez são essencialmente apenas um número de identificação referenciado em um mapeamento para um endereço específico no livro digital.\n\nEntão, com isso em mente, na mesma pasta que a `flow.json` arquivo, crie um novo arquivo chamado `FlowTutorialMint.cdc`, e digite o seguinte código:\n\nCoisas importantes a serem observadas no contrato inteligente acima:\n\n- Estamos importando o `NonFungibleTokenMetadataViews`\n    \n    e\n    \n    contratos para criar nossas NFTs usando os padrões Flow\n    \n- Definimos nosso recurso NFT no `pub resource NFT`\n    \n    função\n    \n- O `mintNFT`\n    \n    função cunha uma NFT na conta que chama a função\n    \n\nAgora precisamos voltar ao nosso `flow.json` arquivo para adicionar algumas coisas:\n\n- No `contracts`\n    \n    seção, adicione o contrato e seu caminho.\n    \n- No `deploymentstestnettestnet-accountFlowTutorialMint`\n    \n    seção adicionar a rede (\n    \n    ), a conta que usaremos para executar a implantação (\n    \n    ) e o nome do contrato (\n    \n    ).\n    \n\n```\n{\n \"emuladores\": {\n  \"padrão\": {\n   \"porta\":3569,\n\"Conta de serviço\":\"conta de emulador\"\n  }\n },\n \"contratos\": {\n  \"FlowTutorialMint\":\"./FlowTutorialMint.cdc\"\n },\n \"redes\": {\n  \"emulador\":\"127.0.0.1: 3569\",\n\"mainnet\":\"access.mainnet.nodes.onflow.org: 9000\",\n\"testnet\":\"access.devnet.nodes.onflow.org: 9000\"\n },\n \"contas\": {\n  \"conta de emulador\": {\n   \"endereço\":\"f8d6e0586b0a20c7\",\n\"chave\":\"2becfbede2fb89796ab68df3ec2a23c3627235ec250a3e5da41df850a8dd4349\"\n  },\n  \"conta de rede de teste\": {\n   \"endereço\":\"0x8e0dac5df6e8489e\",\n\"chave\":\"c91f4716a51a66683ccb090ca3e213b90e9f9ae2b1edd12defffe06c57edc\"\n  }\n },\n \"implantações\": {\n  \"rede de teste\": {\n   \"conta de rede de teste\": [\n\"FlowTutorialMint\"\n   ]\n  }\n }\n}\n```\n\nA etapa final na configuração do contrato inteligente é implantá-lo na rede de teste. Para fazer isso, digite o seguinte comando na pasta do projeto no seu terminal:\n\n```\nimplantação do projeto de fluxo -n = testnet\n```\n\nDevemos receber uma saída informando que o contrato foi implantado com sucesso:\n\n![https://miro.medium.com/max/700/1*TDLQtMd43FRRCVVHRWNnkw.jpeg](https://miro.medium.com/max/700/1*TDLQtMd43FRRCVVHRWNnkw.jpeg)\n\nÉ importante observar aqui que os contratos inteligentes da Cadence existem no armazenamento da conta que os implanta, enquanto que, com o Solidity, o contrato inteligente existe em seu próprio endereço na blockchain.\n\nEmbora existam limites para a capacidade de armazenamento da conta, eles são relativos ao número de tokens FLOW reservados na conta. Você pode aprender mais sobre o armazenamento da conta no [Portal do desenvolvedor de fluxo](https://developers.flow.com/learn/concepts/storage).\n\nImpressionante! Agora vamos criar um frontend simples para interagir com o nosso contrato.\n\n# **3). Criando o frontend**\n\nPara o front-end deste projeto, usaremos o React. Primeiro, navegue até uma nova pasta e execute o seguinte comando para criar um projeto de reação:\n\n```\nnpx create-react-appfluxo-tutorial\n```\n\nEm seguida, navegue até a pasta do tutorial de fluxo e instale o [Flow Client Library](https://developers.flow.com/tools/fcl-js) ( FCL ):\n\n```\nnpmeu -S@onflow/fcl\n```\n\nO FCL nos permitirá comunicar com o blockchain Flow, transações de chamadas e integrar todas as outras carteiras compatíveis com FCL sem precisar adicionar integrações personalizadas. Quando isso terminar, instalaremos algumas dependências adicionais:\n\n```\nnpmeu componentes elípticos estilizados em sha3\n```\n\nDepois de instalar todas as nossas dependências, estamos prontos para começar a trabalhar no front-end do dapp.\n\n## **3.a. Configurar o FCL**\n\nAntes de começarmos a estruturar e modelar as coisas, vamos criar um arquivo de configuração FCL onde definiremos configurações importantes, como se iremos interagir com a rede de teste ou a rede principal.\n\nNo `src` diretório, crie uma nova pasta chamada `flow`. Dentro desta nova pasta, crie um arquivo chamado `config.js`.\n\nNisto `config.js` arquivo, vamos importar o FCL, chame o `fcl.config` funcione e crie algumas configurações para o nosso dapp, como:\n\n- `app.detail.title`\n- `accessNode.api`\n- `discovery.wallet`\n\nAbra o `config.js` arquive e preencha com o seguinte código:\n\n```\nconst fcl =requer(\"@onflow / fcl\");\n\nfcl.config( {\n\"app.detail.title\":\"Tutorial da página de menta de fluxo\",// isso adiciona um nome personalizado à nossa carteira\n\"accessNode.api\":\"https://rest-testnet.onflow.org\",// isto é para o emulador local\n\"discovery.wallet\":\"https://fcl-discovery.onflow.org/testnet/authn\",// isto é para a carteira dev local\n} )\n```\n\nHá [configurações adicionais que podemos configurar](https://github.com/onflow/fcl-js/tree/master/packages/config/src#overview) para o nosso dapp, mas por enquanto, é tudo o que precisaremos.\n\nCom a configuração fora do caminho, vamos para a construção!\n\n## **3.b. A estrutura inicial**\n\nPrimeiro, navegue até o `App.js` arquivo no `src` pasta e substitua o código por:\n\n```\nimportar'./App.css';\n\nfunçãoAplicativo() {\n\nRetorna (\n    < div className = \"App\" >\n        < h1 > Menta o seu cão!< / h1 >\n    < / div >\n  );\n}\n\nexportaçãopadrãoAplicativo;\n```\n\nIsso nos dará a estrutura inicial do nosso dapp, da qual expandiremos.\n\nEm seguida, estilizaremos essa estrutura. Abra o `index.css` arquive e substitua o código pelo seguinte:\n\n```\n@import url ('https://fonts.googleapis.com/css2?family=Michroma&family=Montserrat:wght@200;300;600;700&display=swap');\n\ncorpo {\nmargem:0;\nfamília de fontes:'Montserrat', -apple-system, BlinkMacSystemFont,'Segoe UI','Roboto','Oxigênio',\n'Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',\n    sans-serif;\n  -webkit-suavização de fonte: antialiased;\n  -moz-osx-suavização de fonte: escala de cinza;\n}\n\ncódigo {\nfamília de fontes: código-fonte-pro, Menlo, Mônaco, Consolas,'Courier New',\n    monoespaço;\n}\n```\n\nSe você executar o npm start, verá uma página em branco com o título Mint Your Dog!\n\nEm seguida, vamos criar alguns componentes!\n\n## **3.c. O componente nav**\n\nDentro do `src` diretório, crie uma nova pasta chamada `components`, onde construiremos todos os nossos componentes de reação personalizados.\n\nO primeiro componente que criaremos é o Navbar, que mostrará o botão Login se o usuário não estiver conectado, ou o botão Logout ao lado do endereço do usuário e o número de tokens FLOW que a conta possui se estiverem conectados.\n\nCrie um arquivo chamado `Navbar.jsx` e preencha com o seguinte código:\n\nVamos percorrer o código para ver o que está acontecendo aqui.\n\n- Primeiro, estamos importando a Flow Client Library, que nos fornecerá funções para `authenticateunauthenticatecurrentUser`\n    \n    ,\n    \n    , e determine o\n    \n    .\n    \n- Em seguida, importamos as outras dependências de que precisamos e depois usamos `styled-componentsWrapper`\n    \n    para criar o estilo básico do nosso Navbar dentro do\n    \n    variável.\n    \n- Em seguida, definimos algumas variáveis de estado de reação (`userflow`\n    \n    e\n    \n    ).\n    \n- Em seguida é a funcionalidade do dapp, como `logOutlogIngetFlow`\n    \n    ,\n    \n    , e\n    \n    ( obtenha o saldo de FLUXO da conta conectada ).\n    \n- Depois disso, devolvemos o `html`\n    \n    para o Navbar envolto em nosso estilo.\n    \n\nCom um completo `Navbar` componente, agora podemos importá-lo para o `App.js` Arquivo:\n\n```\nimportar'./App.css';\nimportarBarra de navegaçãode'./«./components/Navbar.jsx»';\n\nfunçãoAplicativo() {\n\nRetorna (\n    < div className = \"App\" >\n        < Navbar / >\n        < h1 > Menta seu cão!< / h1 >\n    < / div >\n  );\n}\n\nexportaçãopadrãoAplicativo;\n```\n\nAgora, se executarmos o projeto com `npm start`, vemos a nossa `Navbar` nos fornece a funcionalidade que definimos em nosso código. Impressionante!\n\nEm seguida, vamos construir nosso componente de cunhagem NFT!\n\n## **3.d. O componente de cunhagem NFT**\n\nDentro do `components` pasta, crie um novo arquivo chamado `MintComponent.jsx`, copie o seguinte código:\n\nNovamente, vamos percorrer o código para garantir que entendemos o que está acontecendo.\n\n- Precisamos importar a FCL neste componente para obter acesso à função que nos permitirá cunhar nossa NFT.\n- Novamente, usamos `styled-components`\n    \n    para adicionar um pouco de estilo.\n    \n\nO `mintNFT` função usa `fcl.mutate` função para executar a hortelã real por:\n\n- Validando se o usuário possui uma coleção NFT de Tutorial de Fluxo em sua conta e criando uma, se não.\n- Chamando a função de hortelã existente dentro do contrato FlowTutorialMint e passando os parâmetros.\n- A função retorna o recurso ( NFT ), que depositamos na conta do usuário.\n- No `fcl.mutateimport FlowTutorialMint from 0x8e0dac5df6e8489e`\n    \n    função, estamos importando o contrato inteligente que implantamos com a linha:\n    \n- Também importamos o `NonFngibleTokenMetadataViews`\n    \n    e\n    \n    padrões.\n    \n- Na transação, especificamos a NFT `typeurl`\n    \n    e\n    \n    da imagem.\n    \n\nAs transações de cadência têm duas fases: `prepare` e `execute`\n\n- `prepareFlowTutorialCapabilityNonFungibleToken.CollectionPublic`[confira este link](https://developers.flow.com/cadence/tutorial/04-capabilities)\n    \n    – solicitamos a assinatura do usuário para acessar sua conta e executar funções privadas. Nesse caso, criando um novo\n    \n    Coleção de hortelã, se eles ainda não tiverem um. Também inicializamos um público\n    \n    restrito a\n    \n    . Para mais contexto sobre Recursos,\n    \n    .\n    \n- `executemintNFT`\n    \n    – chame o\n    \n    função dentro do nosso contrato na rede de teste.\n    \n- No `html`\n    \n    parte do código, exibimos três imagens das quais o usuário pode cunhar uma NFT.\n    \n\nCom a nossa `MintComponent` completo, podemos importá-lo para o `App.js` Arquivo:\n\n```\nimportar'./App.css';\nimportarBarra de navegaçãode'./«./components/Navbar.jsx»';\nimportarComponente de hortelãde'./components/MintComponent.jsx';\n\nfunçãoAplicativo() {\n\nRetorna (\n    < div className = \"App\" >\n        < Navbar / >\n        < h1 > Menta seu cão!< / h1 >\n        < Componente de menta / >\n    < / div >\n  );\n}\n\nexportaçãopadrãoAplicativo;\n```\n\nAgora o usuário pode fazer login no dapp e cunhar uma NFT em sua conta!\n\nA peça final do quebra-cabeça é criar um componente que buscará as NFTs do usuário e as exibirá.\n\n## **3.e. Mostrando as NFTs do usuário**\n\nNo `components` pasta, crie um novo arquivo chamado `ShowNfts.jsx`, e usaremos o seguinte código:\n\nEssencialmente, o que estamos fazendo neste código é consultar o Flow Blockchain usando o FCL e reunir as NFTs na conta conectada que são da nossa `FlowTutorialMint` coleção.\n\nSó precisamos adicionar esse componente ao nosso `App.js`, e estamos prontos para ir!\n\n```\nimportar'./App.css';\nimportarBarra de navegaçãode'./«./components/Navbar.jsx»';\nimportarComponente de hortelãde'./components/MintComponent.jsx';\nimportarShowNftsde'./«./components/ShowNfts»';\n\nfunçãoAplicativo() {\n\nRetorna (\n    < div className = \"App\" >\n      < Navbar / >\n      < h1 > Menta seu cão!< / h1 >\n      < Componente de menta / >\n      < ShowNfts / >\n    < / div >\n  );\n}\n\nexportaçãopadrãoAplicativo;\n```\n\nIsso é tudo! Agora vamos testar nosso dapp e garantir que podemos cunhar algumas NFTs.\n\n## **4). Vamos cunhar algumas NFTs!**\n\nEntão, primeiro, vamos começar o aplicativo com `npm start` e então abra nosso navegador para `[http://localhost:3000/](http://localhost:3000/)`.\n\nSe tudo correr bem, sua tela ficará assim:\n\n![https://miro.medium.com/max/700/1*QEzqQSSfMqemHV7-vokCVA.png](https://miro.medium.com/max/700/1*QEzqQSSfMqemHV7-vokCVA.png)\n\nO mais bonito de usar o FCL em nossa sequência de login é que ele oferece aos usuários acesso fácil a fazer uma conta no local usando apenas um endereço de email. Vamos percorrer o processo para garantir que ele funcione corretamente. Ao clicar no botão Login, um diálogo será aberto, oferecendo duas opções para fazer login. Vamos escolher o Blocto.\n\n![https://miro.medium.com/max/501/1*kWffHiB_OdlWkbhkUT8P_Q.png](https://miro.medium.com/max/501/1*kWffHiB_OdlWkbhkUT8P_Q.png)\n\nA Blocto nos solicitará a inserir um endereço de e-mail e, ao fazer isso, nos dará a capacidade de registrar uma nova conta. Então, depois de inserir o código enviado por e-mail para o nosso endereço, o Blocto nos configura com um novo e brilhante endereço Flow!\n\n![https://miro.medium.com/max/452/1*R1pIcmUN7E_DsGdmsxEnHA.png](https://miro.medium.com/max/452/1*R1pIcmUN7E_DsGdmsxEnHA.png)\n\nA partir daqui, podemos escolher qual imagem de cachorro queremos cunhar como NFT. Eu escolhi o Swag Dog porque isso me lembra um pouco de mim!\n\n![https://miro.medium.com/max/295/1*k2n-4Bs8DhL9mlyFXmimeg.png](https://miro.medium.com/max/295/1*k2n-4Bs8DhL9mlyFXmimeg.png)\n\nPressionar o botão Mint abrirá outro diálogo nos informando sobre a transação que estamos prestes a realizar. Podemos ver que o Blocto está cobrindo graciosamente as taxas de cunhagem e, se quisermos olhar para o script que estamos chamando, podemos fazê-lo.\n\n![https://miro.medium.com/max/416/1*-8oJUrVK87ngEjG5JQEhew.png](https://miro.medium.com/max/416/1*-8oJUrVK87ngEjG5JQEhew.png)\n\nVários segundos depois de clicar em Aprovar, devemos receber uma mensagem de que nossa hortelã foi bem-sucedida e nosso cão Swag recém-cunhado será exibido na seção Minhas NFTs do nosso dapp.\n\nAqui está um link para o nosso dapp em ação:\n\n[https://s1.gifyu.com/images/capas/flow_tutorial-min.gif](https://s1.gifyu.com/images/capas/flow_tutorial-min.gif)\n\nTodo o código fonte deste projeto pode ser encontrado em [este repositório](https://github.com/paul-mcaviney/flow-nft-minting-dapp-project).\n\n# **Conclusão**\n\nComo você pode ver, a construção de um dapp de cunhagem NFT no Flow Blockchain é direta quando você entende como tudo funciona em conjunto. Além disso, a Flow Client Library é uma ferramenta poderosa à nossa disposição que nos dá acesso a uma extensa funcionalidade interna e ajuda a proporcionar ao nosso dapp uma melhor experiência do usuário.\n\nAo contrário do Ethereum, o Flow lida com a criação e o gerenciamento de NFT de maneira muito mais eficiente e segura. Isso é conseguido implantando contratos inteligentes e cunhando as NFTs diretamente na conta do usuário, em vez de criar uma referência a endereços ou mapeamentos armazenados no livro digital.\n\nInspirado em artigo original em inglês: https://betterprogramming.pub/how-to-build-an-nft-minting-dapp-on-the-flow-blockchain-d331a2404cae"},{"__metadata":{"id":"content/pages/blog/como-a-programacao-orientada-a-recursos-funciona.md","source":"sourcebit-source-filesystem","sourceName":"pages","sourcePath":"/Users/coflow/Desktop/digifi_ei/content/pages","relSourcePath":"blog/como-a-programacao-orientada-a-recursos-funciona.md","relProjectPath":"content/pages/blog/como-a-programacao-orientada-a-recursos-funciona.md"},"layout":"PostLayout","metaTitle":"Como a programação orientada a recursos funciona? ","addTitleSuffix":true,"metaTags":[],"title":"Como a programação orientada a recursos funciona? ","colors":"colors-d","date":"2022-12-06","excerpt":"O objetivo da Dapper Labs é usar a tecnologia descentralizada, especificamente non-fungible tokens (NFTs), para dar poder aos criadores e permitir que eles monetizem e promovam o próprio trabalho de maneira mais eficiente. A empresa acredita que as NFTs ainda têm um grande potencial para redefinir a criatividade, as comunidades de fãs e as experiências dos consumidores na blockchain. A Dapper Labs tem trabalhado em produtos como NBA Top Shot, CryptoKitties, NFL All Day, Dapper Wallet e outros para mostrar como as NFTs podem ser usadas para criar novas experiências, conectar fãs e criar conexões mais profundas no mundo digital. A empresa acredita que as NFTs são poderosas para permitir a participação e o envolvimento das comunidades, bem como para permitir que os fãs apoiem criadores e comunidades e expressem a própria individualidade.","featuredImage":{"type":"ImageBlock","url":"/images/capas/Como a programação orientada a recursos funciona diegofornalha.png","altText":"Como a programação orientada a recursos funciona?","caption":"O EVM (Ethereum Virtual Machine) ou WASM (WebAssembly) são opções ideais para ativos digitais, pois permitem que esses ativos sejam rotulados como \"recursos\" e sejam acompanhados por regras especiais que mantêm seu valor. Essas regras incluem a existência exclusiva de um recurso em um lugar específico, a impossibilidade de duplicação ou exclusão acidental e a propriedade determinada pelo local de armazenamento. Além disso, o acesso aos métodos de um recurso é limitado ao proprietário e as regras devem ser aplicadas enquanto o código é executado na blockchain para evitar invasões. Se essas regras forem seguidas corretamente, é possível armazenar ativos importantes de forma segura em estruturas de dados controladas por código de usuário. Um exemplo de como isso pode ser aplicado é o uso de tokens não fungíveis (NFTs) como CryptoKitties, que são indivisíveis, não copiáveis e podem ter um único proprietário direto. No modelo de recursos, o próprio CryptoKitty é armazenado diretamente na conta do proprietário, enquanto no modelo de ledger, é armazenado em um contrato inteligente centralizado.","width":800,"height":450},"media":{"type":"ImageBlock","url":"/images/capas/Como a programação orientada a recursos funciona diegofornalha.png","altText":"Como a programação orientada a recursos funciona? ","caption":"O EVM (Ethereum Virtual Machine) ou WASM (WebAssembly) são opções ideais para ativos digitais, pois permitem que esses ativos sejam rotulados como \"recursos\" e sejam acompanhados por regras especiais que mantêm seu valor. Essas regras incluem a existência exclusiva de um recurso em um lugar específico, a impossibilidade de duplicação ou exclusão acidental e a propriedade determinada pelo local de armazenamento. Além disso, o acesso aos métodos de um recurso é limitado ao proprietário e as regras devem ser aplicadas enquanto o código é executado na blockchain para evitar invasões. Se essas regras forem seguidas corretamente, é possível armazenar ativos importantes de forma segura em estruturas de dados controladas por código de usuário. Um exemplo de como isso pode ser aplicado é o uso de tokens não fungíveis (NFTs) como CryptoKitties, que são indivisíveis, não copiáveis e podem ter um único proprietário direto. No modelo de recursos, o próprio CryptoKitty é armazenado diretamente na conta do proprietário, enquanto no modelo de ledger, é armazenado em um contrato inteligente centralizado.","width":800,"height":450},"bottomSections":[],"metaDescription":null,"socialImage":null,"author":null,"markdown_content":"Entre as opções que EVM ou WASM e são um ajuste perfeito para ativos digitais.\n\nA rotulagem de algo como um “recurso” informa ao ambiente de programação que essa estrutura de dados representa algo de valor tangível e que todo código que interage com essa estrutura de dados precisa seguir uma série de regras especiais que manterão o valor dessa estrutura de dados.\n\nEntão, quais são essas regras?\n\n1.  **Cada recurso existe exatamente em um lugar a qualquer momento.**\n\nOs recursos não podem ser duplicados ou excluídos acidentalmente, por erro de programação ou código malicioso.\n\n2.  **A propriedade de um recurso é definida por onde ele é armazenado.**\n\nNão há razão central que precise ser consultada para determinar a propriedade.\n\n3.  **O acesso aos métodos em um recurso é limitado ao proprietário.**\n\nPor exemplo, apenas o proprietário de um CryptoKitty pode iniciar uma operação de criação que levará ao nascimento de um novo Kitty.\n\nNão basta que o status especial dos objetos Resource seja aplicado apenas pelo compilador.\n\nAs regras devem ser aplicadas enquanto o código estiver realmente sendo executado na blockchain, seria muito fácil para um invasor usar uma cópia comprometida do compilador que ignora as regras que mantêm os recursos seguros.\n\nContudo! Se você aplicar essas regras corretamente, poderá permitir que o ativo mais importante da rede do token nativo seja armazenado com segurança dentro de estruturas de dados controladas por código enviado pelo usuário.\n\n# **Mostre-me um exemplo!**\n\nA maneira mais fácil de pensar sobre Recursos é pensar em um exemplo usando um Token Não Fungível (NFT), como um CryptoKitty.\n\nCada CryptoKitty é indivisível, não copiável e pode ter um único proprietário direto, que corresponde diretamente à construção de programação de Recursos.\n\nEm um modelo de Ledger como o Ethereum, todos os CryptoKitties são armazenados em um único contrato inteligente como uma lista gigante. A propriedade de cada Kitty é rastreada armazenando o ID da conta de cada proprietário em um livro central, e a única maneira de alterar a propriedade de uma Kitty é entrar em contato com o livro central e solicitar que ele atualize o ID da conta associado a essa Kitty.\n\n`contract KittyLedger {     struct Kitty {}     priv let kitties: {Int: Kitty}     fun transfer(kittyId: Int, newOwner: AccountId) {         if (msg.sender == kitties[kittyId].owner) {             kitties[kittyId].owner = newOwner         }     } } transaction(signer: Account) {     // diz ao razão central para atribuir a propriedade de     // myKittyId para uma conta diferente centralKittyLedger.transfer(myKittyId, receiverAccountId) }`\n\nNo Modelo de Recursos, o próprio Kitty é representado como um objeto de Recursos e é armazenado \\*diretamente na conta que a possui.\n\n\\*Assim como no mundo físico, a propriedade é representada pela posse. Você não precisa procurar em um livro central para ver se possui algo, ou o armazena em sua conta ou não.\n\nE se você tiver, pode transferi-lo ou controlá-lo de outra forma, e se você *não* tem, não há como capturá-lo ou alterá-lo.\n\n`contract CryptoKitties {     //As contas armazenam uma coleção em seu recurso de armazenamento de conta KittyCollection {         // Cada coleção tem funções para //mover recursos armazenados para dentro e para fora         fun withdraw(kittyId: int): CryptoKitty         fun deposit(kitty: CryptoKitty)     }     //Os objetos de recurso que podem ser armazenados no recurso de coleção CryptoKitty {} } transaction(signer: Account) {     //Remove o Kitty da coleção do signatário e o armazena     // temporariamente na pilha.      let theKitty <- signer.kittyCollection.withdraw(kittyId: myKittyId)     // Move o Kitty para a conta do destinatário     let receiver = getAccount(receiverAccountId)     receiver.kittyCollection.deposit(kitty: <-theKitty) }`\n\n*Nota: para manter o foco nas diferenças entre os modelos de contabilidade e propriedade direta, os dois exemplos acima ignoram questões como controle de acesso, definindo todas as variáveis, e outros fatores com os quais o código ativo precisaria se preocupar.*\n\n# **Por que os recursos importam**\n\nAlém da vitória óbvia de incluir abstrações para gerenciar a propriedade, existem vários outros benefícios secundários decorrentes do uso de Recursos, cada um dos quais bastante significativo por si só:\n\n# **Aluguel de Estado**\n\nAs plataformas escaláveis de contratos inteligentes precisam de alguma maneira de cobrar “ aluguel de estado ” para que os dados armazenados no blockchain sejam pagos ou removidos do conjunto de trabalho.\n\nCom o modelo de contabilidade, é difícil saber quem deve pagar esse aluguel. Por exemplo, o contrato CryptoKitties representa dezenas de milhares de jogadores com quase dois milhões de Kitties e mais de 111MB de dados na blockchain.\n\nA Ethereum não fornece nenhuma maneira de cobrar aluguel de maneira justa a todos os proprietários da Kitty.\n\nUsando um modelo de propriedade direta via Tipos de Recursos, cada Kitty seria armazenada dentro da conta de seu proprietário, juntamente com os outros ativos dessa pessoa.\n\nA responsabilidade de quem precisa pagar por esse armazenamento é clara.\n\nAlém disso, usuários individuais (assistidos pelo software cliente) podem arquivar ativos não utilizados para reduzir seus custos e reduzir a carga na rede.\n\n# **Propriedade flexível**\n\nO uso de um modelo de contabilidade para propriedade limita os tipos de relacionamentos com proprietários disponíveis.\n\nPor exemplo, o ERC-721 define um modelo de propriedade para NFTs que pressupõe que apenas endereços Ethereum podem possuir uma NFT.\n\nNo entanto, a ideia de um ativo em si possuir outros ativos (como um CryptoKitty que possui um par bacana de óculos de sol ) é muito interessante em alguns casos de uso, e exigiu a criação de uma nova especificação (ERC-998).\n\nO ERC-998 é muito poderoso, mas também é muito mais complicado que o ERC-721. Implementá-lo adequadamente é muito difícil e aplicar retroativamente seus recursos aos ativos existentes do ERC-721 é efetivamente impossível.\n\nO modelo de propriedade direta permite que qualquer ativo modelado usando Tipos de Recursos seja armazenado com segurança em qualquer lugar do sistema, incluindo “dentro” de outros ativos, quando apropriado.\n\nTodas as garantias de segurança e valor podem ser mantidas pelo sistema de tempo de execução, enquanto desbloqueia a flexibilidade criativa para desenvolvedores sem complexidade indevida.\n\n# **Segurança baseada em capacidade**\n\nOs tipos de recursos fornecem todas as garantias necessárias para implementar o conceito de “Capacidades” do [Segurança baseada em capacidade](https://en.wikipedia.org/wiki/Capability-based_security) modelo. Os recursos são um mecanismo poderoso para definir sistemas seguros e podem facilitar a adesão ao [Princípio do Menos Privilégio](https://en.wikipedia.org/wiki/Principle_of_least_privilege) (uma prática recomendada comum em sistemas de segurança).\n\nOs modelos de segurança baseados em capacidade são geralmente considerados muito mais fáceis de raciocinar sobre, (o que aumenta a segurança), permitindo maior flexibilidade.\n\n# **Eliminando erros de reentrada**\n\n[O bug de contrato inteligente mais famoso da história da Ethereum](https://www.wired.com/2016/06/50-million-hack-just-showed-dao-human/) foi devido a um problema de reentrada, e os desenvolvedores de solidity precisa estar constantemente vigilantes contra a introdução de fluxo lógico suscetível a ataques de reentrada.\n\nFelizmente, os métodos definidos nos recursos dos objetos não podem ser vítimas de nenhuma exploração de reentrada.\n\nParece uma afirmação ousada! No entanto, segue naturalmente como os Recursos são definidos: cada Recurso tem um único proprietário e somente o proprietário de um Recurso pode chamar os métodos nele.\n\nSe um método de recurso estiver “na pilha”, sabemos que a referência de propriedade única a esse objeto já está em uso simplesmente não é possível que qualquer código que chamamos de dentro desse método, no entanto indiretamente, obtenha uma segunda referência a esse objeto para fazer uma chamada de método reentrante.\n\nObviamente, trabalhar diretamente com o estado compartilhado global (ignorando o uso de objetos de Recursos) ainda pode criar um código vulnerável a erros de reentrada.\n\nÉ por isso que o estilo idiomático de cadência é usar Recursos para todo o estado compartilhado autores de contratos inteligentes que adotam Recursos nunca precisam pensar em bugs de reentrada novamente!\n\n# **Mais sobre recursos**\n\nPara aprofundar os recursos e a programação orientada a recursos, você pode:\n\n*   Leia o [Mover papel técnico](https://developers.libra.org/docs/assets/papers/libra-move-a-language-with-programmable-resources/2019-09-26.pdf)[documentos do desenvolvedor](https://developers.libra.org/docs/move-overview) e\n\n*   Leia o [Documentos do desenvolvedor de Flow](https://docs.onflow.org/docs)[Introdução à Cadence](https://docs.onflow.org/docs/introduction)\n\n*   Aprenda a linguagem de programação Cadence em [Flow Playground](https://www.onflow.org/play)\n"}]}],"metaDescription":null,"socialImage":"/images/capas/a anatomia da uma dapp diego fornalha.png","date":"2023-01-01","markdown_content":"O diagrama abaixo descreve os componentes de um dapp típico construído na blockchain Flow. Embora muitos dapps sejam estruturados de maneira diferente, essa arquitetura apresenta conceitos fundamentais que serão discutidos ao longo deste guia.\n\n**Cliente Dapp**\nO cliente dapp é a interface através da qual os usuários interagem com seu dapp. Aplicativos da Web e móveis são exemplos comuns de clientes dapp.\n\n**Contrato Inteligente**\nUm contrato inteligente é uma coleção de código, implantado em um local permanente na blockchain, que define a lógica central de um dapp.\n\n**Conta de usuário**\nUma conta de usuário é um registro na blockchain que armazena os ativos digitais pertencentes a um único usuário.\n\n**Transação**\nUma transação é um pedaço de código submetido ao blockchain que altera o estado de uma ou mais contas de usuário e contratos inteligentes. Todas as transações são originadas de pelo menos uma conta de usuário. Na maioria dos casos, uma transação passa dados entre uma conta de usuário e um contrato inteligente.\n\n**consulta de estado**\nUma consulta de estado é uma solicitação feita ao blockchain que retorna informações sobre o estado dos contratos inteligentes do seu dapp.\n\n**Carteira do usuário**\nUma carteira de usuário é um software ou hardware que controla o acesso à conta de um usuário na blockchain. O aplicativo cliente normalmente se conecta à carteira do usuário para enviar transações para a blockchain. Em muitos casos, o dapp transmite fisicamente a transação para o blockchain em nome do usuário. No entanto, é importante observar que a carteira tem a palavra final sobre o que é assinado ou não e, portanto, tem controle sobre todas as transações que interagem com a conta do usuário.\n\n**Biblioteca de cliente Flow(FCL)**\nA Flow Client Library é uma estrutura que fornece uma interface padrão para conectar aplicativos clientes e carteiras de usuários.\n"},"site":{"__metadata":{"id":"content/data/config.json","source":"sourcebit-source-filesystem","sourceName":"data","sourcePath":"/Users/coflow/Desktop/digifi_ei/content/data","relSourcePath":"config.json","relProjectPath":"content/data/config.json"},"type":"Config","header":{"headerVariant":"variant-b","isSticky":true,"primaryColors":"colors-b","secondaryColors":"colors-d","isTitleVisible":false,"primaryLinks":[{"type":"Link","label":"Home","altText":"Inicio","url":"/","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"DropdownLink","label":"About","dropdownLinks":[{"type":"Link","label":"Curso Cadence","url":"/curso","altText":"Curso Cadence"},{"type":"Link","label":"Blog","altText":"Blog","url":"/blog","showIcon":true,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"Learn More","altText":"","url":"/curso","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""}]},{"type":"DropdownLink","label":"Volunteers","dropdownLinks":[{"type":"Link","label":"2023","altText":"Link to 2023 team's page","url":"/registro/2023","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"Advocates","altText":"Advocates","url":"https://flow.coflow.com.br/flow-brasil-embaixador-aprendiz/","showIcon":true,"icon":"arrowRight","iconPosition":"right","elementId":""}]},{"type":"DropdownLink","label":"Partnerships","altText":"Parcerias","dropdownLinks":[{"type":"Link","label":"GeekHunter","altText":"Recurtamento e Seleção","url":"/2023/janeiro/parcerias/geekhunter/","showIcon":true,"icon":"arrowRight","iconPosition":"left","elementId":""},{"type":"Link","label":"News","altText":"Novidades","url":"/2023/janeiro/news","showIcon":true,"icon":"arrowRight","iconPosition":"right","elementId":""}]},{"type":"Link","label":"Blog ","altText":"Blog","url":"/blog","showIcon":true,"icon":"arrowRightCircle","iconPosition":"left","elementId":""}],"secondaryLinks":[{"type":"Button","label":"Join Discord","altText":"Entrar no Discord","style":"secondary","url":"https://discord.com/invite/hT8EpC5mUN","showIcon":true,"icon":"cart","iconPosition":"right","elementId":""}],"styles":{"self":{"width":"wide","padding":["pl-5","pt-5","pb-5","pr-5"]}},"logo":{"type":"ImageBlock","url":"/images/padrao/flow-coflow-logo.png","altText":"CoFlow Logo","caption":"CoFlow","width":114,"height":48,"elementId":""},"title":"CoFlow"},"footer":{"variant":"variant-b","colors":"colors-b","contacts":{"addressAltText":"Our address"},"copyrightText":"CoFlow","primaryLinks":[{"type":"Link","label":"Home","url":"/","altText":"Home"},{"type":"Link","label":"Contact Us","altText":"Contact Us","url":"https://wa.me/5521997806363?text=Ol%C3%A1","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"CURSO CADENCE","altText":"CURSO CADENCE","url":"/curso","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"TERMO DE USO","altText":"TERMO DE USO","url":"/termo-de-uso","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""},{"type":"Link","label":"POLÍTICA DE PRIVACIDADE","altText":"POLÍTICA DE PRIVACIDADE","url":"/politica-de-privacidade","showIcon":false,"icon":"arrowRight","iconPosition":"right","elementId":""}],"socialLinks":[{"type":"Social","label":"Email","altText":"","url":"mailto:diegofornalha@gmail.com","icon":"mail","style":"link","elementId":""},{"type":"Social","altText":"Instagram","label":"Instagram","url":"http://www.instagram.com/diegofornalha","icon":"instagram"},{"type":"Social","altText":"Linkedin","label":"Linkedin","url":"https://www.github.com/diegofornalha","icon":"github"},{"type":"Social","label":"Youtube","altText":"Youtube","icon":"youtube","style":"link","elementId":"","url":"https://www.youtube.com/diegofornalha"},{"type":"Social","altText":"Twitter","label":"Twitter","url":"https://twitter.com/diegofornalha","icon":"twitter"},{"type":"Social","label":"Linkedin","altText":"Linkedin","url":"https://linkedin.com/in/diegofornalha","icon":"linkedin","style":"link","elementId":""}],"styles":{"self":{"width":"narrow"}},"logo":{"type":"ImageBlock","url":"/images/padrao/flow-coflow-logo.png","altText":"CoFlow Logo","caption":"CoFlow Logo","width":114,"height":48,"elementId":""}},"defaultMetaTags":[{"type":"MetaTag","property":"og:title","content":"CoFlow"}],"titleSuffix":"Coflow","env":{}}},"__N_SSG":true}